# üîå Sistema de Addons para DataConta

## üìã Introducci√≥n

El **Sistema de Addons de DataConta** permite a la comunidad crear extensiones que ampl√≠an la funcionalidad de la aplicaci√≥n sin modificar el c√≥digo base. Siguiendo los principios de **Arquitectura Hexagonal** y **SOLID**, el sistema proporciona una base s√≥lida y segura para el desarrollo de addons.

## üèóÔ∏è Arquitectura

### **Principios de Dise√±o:**
- ‚úÖ **Arquitectura Hexagonal**: Separaci√≥n clara entre dominio, aplicaci√≥n e infraestructura
- ‚úÖ **Principios SOLID**: Interfaces bien definidas, responsabilidad √∫nica
- ‚úÖ **No-Breaking Changes**: Cero impacto en funcionalidad existente
- ‚úÖ **Security-First**: Validaciones, permisos y sandbox
- ‚úÖ **Hot-Loading**: Carga/descarga din√°mica de addons

### **Componentes Principales:**

#### **1. Core Interfaces (`src/application/ports/addon_interfaces.py`)**
```python
# Interfaces fundamentales
- AddonBase: Clase base para todos los addons
- AddonManager: Gesti√≥n del ciclo de vida de addons  
- AddonRepository: Almacenamiento y carga de addons
- AddonContext: Contexto de dependencias inyectadas
- AddonManifest: Estructura de metadatos del addon
```

#### **2. Infrastructure Adapters (`src/infrastructure/adapters/`)**
```python
# Implementaciones concretas
- FileSystemAddonRepository: Repositorio basado en archivos
- DynamicAddonLoader: Carga din√°mica de m√≥dulos Python
- AddonManagerImpl: Manager principal con ciclo de vida completo
- AddonManifestValidator: Validador con 60+ reglas de seguridad
```

#### **3. Menu Integration (`addon_menu_integration.py`)**
```python  
# Integraci√≥n con men√∫s din√°micos
- AddonMenuIntegration: Integra men√∫s de addons
- EnhancedDynamicMenuManager: Manager extendido compatible
- AddonMenuAction: Acciones espec√≠ficas de addon
```

#### **4. Factory Pattern (`addon_factory.py`)**
```python
# Inyecci√≥n de dependencias
- AddonFactory: Factory para crear sistema completo
- Dependency injection para Logger, MenuManager, etc.
```

## üì¶ Estructura de un Addon

### **Archivo Manifest (`manifest.json`)**
```json
{
  "name": "mi_addon",
  "display_name": "Mi Addon Incre√≠ble", 
  "version": "1.0.0",
  "addon_type": "utility|integration|report|analysis",
  "description": "Descripci√≥n del addon",
  "author": "Desarrollador",
  "license": "MIT",
  "entry_point": "mi_addon.MiAddonClass",
  "requires_license": "FREE|PROFESSIONAL|ENTERPRISE",
  
  "dependencies": ["requests>=2.25.0", "pandas>=1.3.0"],
  
  "permissions": [
    "file_read", "file_write", "api_access", 
    "network_access", "email_send"
  ],
  
  "menu_items": [
    {
      "id": "mi_accion",
      "label": "Mi Acci√≥n", 
      "icon": "üöÄ",
      "action": "execute_my_action",
      "requires_confirmation": true
    }
  ],
  
  "security": {
    "sandbox": true,
    "network_access": true,
    "file_access": "read_only"
  }
}
```

### **Implementaci√≥n del Addon**
```python
from src.application.ports.addon_interfaces import AddonBase, AddonContext

class MiAddon(AddonBase):
    def initialize(self, context: AddonContext) -> bool:
        self.context = context
        self.logger = context.logger
        return True
    
    def execute_action(self, action: str, params: dict) -> bool:
        if action == "execute_my_action":
            return self._mi_logica_personalizada(params)
        return False
    
    def get_name(self) -> str:
        return "mi_addon"
```

## üõ†Ô∏è Gu√≠a de Desarrollo

### **1. Crear Nuevo Addon**

#### **Paso 1: Estructura de Carpetas**
```
addons/
‚îî‚îÄ‚îÄ mi_addon/
    ‚îú‚îÄ‚îÄ manifest.json       # Configuraci√≥n del addon
    ‚îú‚îÄ‚îÄ mi_addon.py        # Implementaci√≥n principal  
    ‚îú‚îÄ‚îÄ README.md          # Documentaci√≥n
    ‚îî‚îÄ‚îÄ requirements.txt   # Dependencias (opcional)
```

#### **Paso 2: Implementar AddonBase**
```python
from src.application.ports.addon_interfaces import AddonBase, AddonContext, AddonManifest
from typing import Dict, Any
import json
from pathlib import Path

class MiAddon(AddonBase):
    def __init__(self):
        super().__init__()
        self.manifest = None
        
    def initialize(self, context: AddonContext) -> bool:
        try:
            self.context = context
            self.logger = context.logger
            
            # Cargar manifest
            manifest_path = Path(__file__).parent / "manifest.json"
            with open(manifest_path, 'r', encoding='utf-8') as f:
                manifest_data = json.load(f)
            self.manifest = AddonManifest(**manifest_data)
            
            # Tu l√≥gica de inicializaci√≥n aqu√≠
            
            return True
        except Exception as e:
            if hasattr(self, 'logger') and self.logger:
                self.logger.error(f"Error inicializando addon: {e}")
            return False
    
    def execute_action(self, action_name: str, parameters: Dict[str, Any] = None) -> bool:
        # Mapear acciones a m√©todos
        action_map = {
            'mi_accion_1': self._accion_1,
            'mi_accion_2': self._accion_2
        }
        
        if action_name in action_map:
            return action_map[action_name](parameters or {})
        return False
    
    def _accion_1(self, params: Dict[str, Any]) -> bool:
        # Implementar l√≥gica espec√≠fica
        if self.logger:
            self.logger.info("Ejecutando acci√≥n 1")
        return True
```

#### **Paso 3: Validar Addon**
```python
# Test b√°sico
from src.infrastructure.adapters.addon_manifest_validator import validate_addon_manifest

is_valid, errors = validate_addon_manifest(
    "addons/mi_addon/manifest.json",
    "addons/mi_addon/"
)

if is_valid:
    print("‚úÖ Addon v√°lido")
else:
    print("‚ùå Errores encontrados:")
    for error in errors:
        print(f"  - {error}")
```

### **2. Tipos de Addons Recomendados**

#### **üîß Utility Addons**
- Herramientas auxiliares
- Calculadoras especializadas
- Conversores de datos
- Validadores personalizados

#### **üîó Integration Addons**  
- Conectores con APIs externas
- Sincronizaci√≥n con otros sistemas
- Webhooks y notificaciones
- Importadores/exportadores

#### **üìä Report Addons**
- Reportes personalizados
- Dashboards espec√≠ficos
- An√°lisis avanzados
- Visualizaciones custom

#### **ü§ñ Analysis Addons**
- Machine Learning
- An√°lisis predictivo
- Detecci√≥n de anomal√≠as
- Clasificaci√≥n autom√°tica

## üîê Sistema de Seguridad

### **Validaciones del Manifest**
- ‚úÖ **Schema JSON**: 60+ reglas de validaci√≥n
- ‚úÖ **Semantic Validation**: Nombres, versiones, dependencias
- ‚úÖ **Security Validation**: Permisos, URLs, dependencias sospechosas
- ‚úÖ **Integrity Validation**: Checksums, estructura de archivos

### **Sistema de Permisos**
```json
{
  "permissions": [
    "file_read",        // Leer archivos del sistema
    "file_write",       // Escribir archivos 
    "api_access",       // Acceso a APIs internas
    "network_access",   // Conexiones de red
    "system_info",      // Informaci√≥n del sistema
    "ui_modify",        // Modificar interfaz
    "menu_add",         // Agregar men√∫s
    "data_export",      // Exportar datos
    "data_import",      // Importar datos
    "email_send",       // Enviar emails
    "notification_send" // Enviar notificaciones
  ]
}
```

### **Sandbox Security**
```json
{
  "security": {
    "sandbox": true,                    // Habilitar sandbox
    "network_access": false,            // Restringir red
    "file_access": "read_only",         // Solo lectura
    "checksum": "sha256_hash_here"      // Verificaci√≥n integridad
  }
}
```

## üöÄ Integraci√≥n con DataConta

### **1. Cargar Sistema de Addons**
```python
from src.infrastructure.factories.addon_factory import AddonFactory
from src.application.ports.interfaces import Logger

# Crear sistema de addons
logger = ConsoleLogger()  # O tu implementaci√≥n de Logger
addon_system = AddonFactory.create_complete_addon_system(
    repository_path="addons/",
    logger=logger
)

# Cargar addons
addon_system.load_all_addons()

# Obtener addons activos
active_addons = addon_system.get_active_addons()
print(f"Addons cargados: {len(active_addons)}")
```

### **2. Integrar con Men√∫s**
```python
from src.infrastructure.adapters.addon_menu_integration import EnhancedDynamicMenuManager
from src.infrastructure.config.dynamic_menu_config import DynamicMenuManager

# Crear manager de men√∫s extendido
menu_manager = EnhancedDynamicMenuManager(
    config_file="menu_config.json",
    addon_manager=addon_system,
    logger=logger
)

# Cargar configuraci√≥n (incluye addons autom√°ticamente)
menu_manager.load_config()

# Obtener botones de men√∫ (sistema + addons)
buttons = menu_manager.create_menu_buttons()
```

### **3. Ejecutar Acciones de Addon**
```python  
# A trav√©s del menu manager
success = menu_manager.execute_action("addon_mi_addon_mi_accion", {"param1": "valor"})

# Directamente con addon manager
addon = addon_system.get_addon("mi_addon")
if addon:
    result = addon.execute_action("mi_accion", {"data": "test"})
```

## üìä Monitoreo y Debugging

### **Logs del Sistema**
```python
# Configurar logging detallado
logger.info("üîÑ Cargando addons...")
logger.debug("üì¶ Addon cargado: email_reports v1.0.0")
logger.warning("‚ö†Ô∏è Addon requiere permisos adicionales")
logger.error("‚ùå Error en addon: permiso denegado")
```

### **Estad√≠sticas de Addons**
```python
# Obtener estad√≠sticas completas
stats = menu_manager.get_menu_statistics()
print(f"""
üìä Estad√≠sticas del Sistema:
   - Categor√≠as del sistema: {stats['system_categories']}
   - Categor√≠as de addons: {stats['addon_categories']}
   - Total acciones: {stats['total_actions']}
   - Addons activos: {len(addon_system.get_active_addons())}
""")
```

### **Validaci√≥n en Tiempo Real**
```python
# Validar addon antes de carga
from src.infrastructure.adapters.addon_manifest_validator import AddonManifestValidator

validator = AddonManifestValidator(logger=logger)
is_valid, errors = validator.validate_manifest(manifest_data, addon_path)

if not is_valid:
    logger.error(f"Addon inv√°lido: {errors}")
```

## üß™ Testing

### **Test de Addon Individual**
```python
# test_mi_addon.py
import unittest
from addons.mi_addon.mi_addon import MiAddon
from src.application.ports.addon_interfaces import AddonContext

class TestMiAddon(unittest.TestCase):
    def setUp(self):
        self.addon = MiAddon()
        self.context = AddonContext(logger=MockLogger())
        
    def test_initialize(self):
        result = self.addon.initialize(self.context)
        self.assertTrue(result)
        
    def test_execute_action(self):
        self.addon.initialize(self.context)
        result = self.addon.execute_action("mi_accion", {})
        self.assertTrue(result)
```

### **Test de Integraci√≥n**
```python  
# test_addon_system.py
def test_complete_addon_system():
    # Crear sistema
    addon_system = AddonFactory.create_complete_addon_system(
        repository_path="test_addons/",
        logger=MockLogger()
    )
    
    # Cargar addons
    loaded = addon_system.load_all_addons()
    assert loaded > 0
    
    # Ejecutar acci√≥n
    success = addon_system.execute_addon_action("test_addon", "test_action", {})
    assert success
```

## üìö Ejemplos de Addons

### **1. Email Reports Addon** (Incluido)
- üìß Env√≠o de reportes por email
- üìä Reportes diarios y mensuales
- ‚öôÔ∏è Configuraci√≥n flexible
- üìç Ubicaci√≥n: `addons/email_reports/`

### **2. Data Analyzer Addon** (Ejemplo)
```python
class DataAnalyzerAddon(AddonBase):
    def execute_action(self, action: str, params: dict) -> bool:
        if action == "analyze_sales_trends":
            return self._analyze_trends(params)
        elif action == "detect_anomalies":
            return self._detect_anomalies(params)
        return False
```

### **3. API Connector Addon** (Ejemplo)
```python
class ApiConnectorAddon(AddonBase):
    def execute_action(self, action: str, params: dict) -> bool:
        if action == "sync_with_external_api":
            return self._sync_data(params)
        elif action == "export_to_webhook":
            return self._export_webhook(params)
        return False
```

## üîÑ Ciclo de Vida de Addon

### **1. Desarrollo**
1. ‚úÖ Crear estructura de carpetas
2. ‚úÖ Implementar AddonBase
3. ‚úÖ Crear manifest.json
4. ‚úÖ Validar con schema JSON
5. ‚úÖ Testing local

### **2. Instalaci√≥n**
1. ‚úÖ Copiar a carpeta `addons/`
2. ‚úÖ Validaci√≥n autom√°tica
3. ‚úÖ Verificaci√≥n de permisos
4. ‚úÖ Carga en sistema

### **3. Ejecuci√≥n**
1. ‚úÖ Inicializaci√≥n con contexto
2. ‚úÖ Registro en men√∫s
3. ‚úÖ Ejecuci√≥n de acciones
4. ‚úÖ Logging y monitoreo

### **4. Mantenimiento**
1. ‚úÖ Actualizaciones de versi√≥n
2. ‚úÖ Re-validaci√≥n de seguridad  
3. ‚úÖ Migraci√≥n de configuraci√≥n
4. ‚úÖ Cleanup de recursos

## üö® Troubleshooting

### **Problemas Comunes**

#### **‚ùå Addon no se carga**
```
Verificar:
- manifest.json es v√°lido JSON
- entry_point apunta a clase correcta
- permissions est√°n bien definidos
- dependencies est√°n instaladas
```

#### **‚ùå Acci√≥n no se ejecuta**
```
Verificar:
- action_name coincide con manifest
- m√©todo execute_action implementado
- permisos suficientes
- logs para m√°s detalles
```

#### **‚ùå Menu no aparece**
```
Verificar:  
- menu_items definidos en manifest
- addon est√° activo
- licencia requerida cumplida
- reload de configuraci√≥n de men√∫s
```

### **Debugging Tips**
```python
# Habilitar logging detallado
logger.set_level(LogLevel.DEBUG)

# Verificar estado del addon
status = addon.get_status()
logger.info(f"Estado del addon: {status}")

# Validar manifest manualmente
validator = AddonManifestValidator(logger=logger)
report = validator.create_validation_report(manifest_data, addon_path)
logger.info(f"Reporte de validaci√≥n: {report}")
```

## üìà Roadmap

### **Versi√≥n Actual (1.0)**
- ‚úÖ Sistema base de addons
- ‚úÖ Validaci√≥n y seguridad
- ‚úÖ Integraci√≥n con men√∫s  
- ‚úÖ Addon de ejemplo (email_reports)
- ‚úÖ Documentaci√≥n completa

### **Versi√≥n 1.1 (Pr√≥ximamente)**
- üîÑ Hot-reload de addons
- üîÑ Marketplace de addons
- üîÑ Sandbox m√°s robusto
- üîÑ API REST para addons

### **Versi√≥n 1.2 (Futuro)**
- üîÑ Visual addon builder
- üîÑ Containerizaci√≥n de addons
- üîÑ Distributed addon system
- üîÑ AI-powered addon suggestions

## ü§ù Contribuci√≥n

### **C√≥mo Contribuir**
1. üç¥ Fork del repositorio
2. üåø Crear branch para addon/feature  
3. üîß Seguir est√°ndares de c√≥digo DataConta
4. ‚úÖ Testing completo con coverage > 80%
5. üìù Documentaci√≥n clara
6. üöÄ Pull request descriptivo

### **Est√°ndares de C√≥digo**
- ‚úÖ Type hints obligatorios
- ‚úÖ Docstrings en todas las funciones
- ‚úÖ PEP 8 compliance
- ‚úÖ Error handling robusto  
- ‚úÖ Logging apropiado
- ‚úÖ Principios SOLID

## üìÑ Licencia

**MIT License** - Sistema de addons desarrollado para DataConta con ‚ù§Ô∏è por la comunidad.

---

## üéØ ¬øListo para crear tu primer addon?

1. üìã Lee esta documentaci√≥n completa
2. üîç Analiza el addon de ejemplo `email_reports`
3. üõ†Ô∏è Sigue la gu√≠a de desarrollo paso a paso  
4. ‚úÖ Valida tu addon con las herramientas incluidas
5. üöÄ ¬°Comparte tu addon con la comunidad!

**¬°El futuro de DataConta est√° en tus manos! üöÄ**